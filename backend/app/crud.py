from sqlalchemy.orm import Session
from . import models, schemas
import json

def get_personas(db: Session, skip: int = 0, limit: int = 100):
    """Retrieve all personas from the database."""
    return db.query(models.Persona).offset(skip).limit(limit).all()

def create_persona(db: Session, persona_data: schemas.PersonaCreate, persona_json: str):
    """
    Create a new persona entry in the database.
    
    Args:
        db: The database session.
        persona_data: The input data used for generation (age, gender, etc.).
        persona_json: The full JSON string generated by the LLM.
    """
    # The persona_json string might contain the name, let's parse it to be safe
    generated_data = json.loads(persona_json)
    
    db_persona = models.Persona(
        name=generated_data.get("name", "Unnamed Persona"),
        age=persona_data.age,
        gender=persona_data.gender,
        condition=persona_data.condition,
        location=persona_data.location,
        full_persona_json=persona_json
    )
    db.add(db_persona)
    db.commit()
    db.refresh(db_persona)
    return db_persona

def get_persona(db: Session, persona_id: int):
    return db.query(models.Persona).filter(models.Persona.id == persona_id).first()

def update_persona(db: Session, persona_id: int, persona: schemas.PersonaCreate):
    db_persona = db.query(models.Persona).filter(models.Persona.id == persona_id).first()
    if db_persona:
        for key, value in persona.dict().items():
            setattr(db_persona, key, value)
        db.commit()
        db.refresh(db_persona)
    return db_persona

def delete_persona(db: Session, persona_id: int):
    db_persona = db.query(models.Persona).filter(models.Persona.id == persona_id).first()
    if db_persona:
        db.delete(db_persona)
        db.commit()
        return True
    return False

def create_simulation(db: Session, simulation: schemas.SimulationCreate):
    db_simulation = models.Simulation(**simulation.dict())
    db.add(db_simulation)
    db.commit()
    db.refresh(db_simulation)
    return db_simulation

def get_simulation(db: Session, simulation_id: int):
    return db.query(models.Simulation).filter(models.Simulation.id == simulation_id).first()

def get_simulations(db: Session, skip: int = 0, limit: int = 100):
    return db.query(models.Simulation).offset(skip).limit(limit).all()

def update_simulation_results(db: Session, simulation_id: int, results: dict, response_rate: float, insights: str):
    db_simulation = db.query(models.Simulation).filter(models.Simulation.id == simulation_id).first()
    if db_simulation:
        db_simulation.results = results
        db_simulation.response_rate = response_rate
        db_simulation.insights = insights
        db.commit()
        db.refresh(db_simulation)
    return db_simulation

def create_cohort_simulation(db: Session, persona_ids: list, stimulus_text: str, results: dict, insights: list):
    """Create simulation records for cohort analysis"""
    # Calculate average response rate from results
    response_rates = []
    for response in results.get('individual_responses', []):
        # Calculate a response rate based on purchase intent (normalized to 0-100)
        if 'purchase_intent' in response.get('responses', {}):
            response_rates.append(response['responses']['purchase_intent'] * 10)  # Convert 1-10 to 10-100
    
    avg_response_rate = sum(response_rates) / len(response_rates) if response_rates else 0
    
    # Store simulation for each persona
    for persona_id in persona_ids:
        db_simulation = models.Simulation(
            persona_id=persona_id,
            scenario=stimulus_text,
            parameters={"metrics": results.get('metrics_analyzed', [])},
            results=results,
            response_rate=avg_response_rate,
            insights=json.dumps(insights)
        )
        db.add(db_simulation)
    
    db.commit()
    return avg_response_rate

def get_simulation_stats(db: Session):
    """Get statistics about simulations"""
    from sqlalchemy import func
    from datetime import datetime, timedelta
    
    # Count total simulations
    total_simulations = db.query(models.Simulation).count()
    
    # Count simulations this month
    start_of_month = datetime.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0)
    monthly_simulations = db.query(models.Simulation).filter(
        models.Simulation.created_at >= start_of_month
    ).count()
    
    # Calculate average response rate
    avg_response_rate = db.query(func.avg(models.Simulation.response_rate)).scalar()
    
    # Count total insights (each simulation can have multiple insights)
    total_insights = 0
    simulations = db.query(models.Simulation).all()
    for sim in simulations:
        if sim.insights:
            try:
                insights_list = json.loads(sim.insights)
                total_insights += len(insights_list)
            except:
                pass
    
    return {
        "total_simulations": total_simulations,
        "monthly_simulations": monthly_simulations,
        "avg_response_rate": avg_response_rate or 0,
        "total_insights": total_insights
    }
